// Generated by CoffeeScript 1.6.3
/*
** Annotator 1.2.6-dev-bd83931
** https://github.com/okfn/annotator/
**
** Copyright 2012 Aron Carroll, Rufus Pollock, and Nick Stenning.
** Dual licensed under the MIT and GPLv3 licenses.
** https://github.com/okfn/annotator/blob/master/LICENSE
**
** Built at: 2014-04-17 01:36:50Z
*/



/*
//
*/

// Generated by CoffeeScript 1.6.3
(function() {
  var DummyDocumentAccess, EnhancedAnchoringManager, Highlight, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Highlight = (function() {
    function Highlight(anchor, pageIndex) {
      this.anchor = anchor;
      this.pageIndex = pageIndex;
      this.annotator = this.anchor.annotator;
      this.annotation = this.anchor.annotation;
    }

    Highlight.prototype.setTemporary = function(value) {
      throw "Operation not implemented.";
    };

    Highlight.prototype.isTemporary = function() {
      throw "Operation not implemented.";
    };

    Highlight.prototype.setActive = function(value, batch) {
      if (batch == null) {
        batch = false;
      }
      throw "Operation not implemented.";
    };

    Highlight.prototype.setFocused = function(value, batch) {
      if (batch == null) {
        batch = false;
      }
      throw "Operation not implemented.";
    };

    Highlight.prototype.annotationUpdated = function() {};

    Highlight.prototype.removeFromDocument = function() {
      throw "Operation not implemented.";
    };

    Highlight.prototype._getDOMElements = function() {
      throw "Operation not implemented.";
    };

    Highlight.prototype.getTop = function() {
      return $(this._getDOMElements()).offset().top;
    };

    Highlight.prototype.getHeight = function() {
      return $(this._getDOMElements()).outerHeight(true);
    };

    Highlight.prototype.getBottom = function() {
      return this.getTop() + this.getBottom();
    };

    Highlight.prototype.scrollTo = function() {
      return $(this._getDOMElements()).scrollintoview();
    };

    Highlight.prototype.paddedScrollTo = function(direction) {
      var defaultView, dir, pad, where, wrapper;
      if (direction == null) {
        throw "Direction is required";
      }
      dir = direction === "up" ? -1 : +1;
      where = $(this._getDOMElements());
      wrapper = this.annotator.wrapper;
      defaultView = wrapper[0].ownerDocument.defaultView;
      pad = defaultView.innerHeight * .2;
      return where.scrollintoview({
        complete: function() {
          var correction, scrollable, top;
          scrollable = this.parentNode === this.ownerDocument ? $(this.ownerDocument.body) : $(this);
          top = scrollable.scrollTop();
          correction = pad * dir;
          return scrollable.stop().animate({
            scrollTop: top + correction
          }, 300);
        }
      });
    };

    Highlight.prototype.paddedScrollUpTo = function() {
      return this.paddedScrollTo("up");
    };

    Highlight.prototype.paddedScrollDownTo = function() {
      return this.paddedScrollTo("down");
    };

    return Highlight;

  })();

  DummyDocumentAccess = (function() {
    function DummyDocumentAccess(rootNode) {
      this.rootNode = rootNode;
    }

    DummyDocumentAccess.applicable = function() {
      return true;
    };

    DummyDocumentAccess.prototype.getPageIndex = function() {
      return 0;
    };

    DummyDocumentAccess.prototype.getPageCount = function() {
      return 1;
    };

    DummyDocumentAccess.prototype.getPageRoot = function() {
      return this.rootNode;
    };

    DummyDocumentAccess.prototype.getPageIndexForPos = function() {
      return 0;
    };

    DummyDocumentAccess.prototype.isPageMapped = function() {
      return true;
    };

    DummyDocumentAccess.prototype.prepare = function() {};

    return DummyDocumentAccess;

  })();

  EnhancedAnchoringManager = (function() {
    function EnhancedAnchoringManager(annotator) {
      var _this = this;
      this.annotator = annotator;
      this.setAnnotationTemporary = __bind(this.setAnnotationTemporary, this);
      this.deleteAnnotation = __bind(this.deleteAnnotation, this);
      this.setupAnnotation = __bind(this.setupAnnotation, this);
      this.onFailedSelection = __bind(this.onFailedSelection, this);
      this.onSuccessfulSelection = __bind(this.onSuccessfulSelection, this);
      this._reanchorAllAnnotations = __bind(this._reanchorAllAnnotations, this);
      this._verifyAllAnchors = __bind(this._verifyAllAnchors, this);
      this._virtualizePage = __bind(this._virtualizePage, this);
      this._realizePage = __bind(this._realizePage, this);
      this.getHighlights = __bind(this.getHighlights, this);
      this._createHighlight = __bind(this._createHighlight, this);
      this._createHighlightUsingHighlighters = __bind(this._createHighlightUsingHighlighters, this);
      this._anchorAllAnnotations = __bind(this._anchorAllAnnotations, this);
      this._anchorAnnotation = __bind(this._anchorAnnotation, this);
      this._hasAnchorForTarget = __bind(this._hasAnchorForTarget, this);
      this._findAnchorForTarget = __bind(this._findAnchorForTarget, this);
      this._removeAnchor = __bind(this._removeAnchor, this);
      this._verifyAnchor = __bind(this._verifyAnchor, this);
      this._virtualizeAnchor = __bind(this._virtualizeAnchor, this);
      this._realizeAnchor = __bind(this._realizeAnchor, this);
      this._createAnchor = __bind(this._createAnchor, this);
      this._createAnchorWithStrategies = __bind(this._createAnchorWithStrategies, this);
      this.findSelector = __bind(this.findSelector, this);
      this._getTargetsFromSelections = __bind(this._getTargetsFromSelections, this);
      this._getTargetFromSelection = __bind(this._getTargetFromSelection, this);
      this.initAnchoring = __bind(this.initAnchoring, this);
      this._chooseAccessPolicy = __bind(this._chooseAccessPolicy, this);
      this._setupAnchorEvents = __bind(this._setupAnchorEvents, this);
      this.registerHighlighter = __bind(this.registerHighlighter, this);
      this.registerDocumentAccessStrategy = __bind(this.registerDocumentAccessStrategy, this);
      this.registerAnchoringStrategy = __bind(this.registerAnchoringStrategy, this);
      this.registerSelectorCreator = __bind(this.registerSelectorCreator, this);
      console.log("Initializing Enhanced Anchoring Manager");
      this.orphans = [];
      this.halfOrphans = [];
      this.anchors = {};
      this._setupAnchorEvents();
      this.registerDocumentAccessStrategy({
        name: "Dummy",
        priority: 99,
        applicable: function() {
          return true;
        },
        get: function() {
          return new DummyDocumentAccess(_this.annotator.wrapper[0]);
        }
      });
      this.removeFromSet = Annotator.Util.removeFromSet;
      this.addToSet = Annotator.Util.addToSet;
      this;
    }

    EnhancedAnchoringManager.prototype._selectorCreators = [];

    EnhancedAnchoringManager.prototype.registerSelectorCreator = function(selectorCreator) {
      return this._selectorCreators.push(selectorCreator);
    };

    EnhancedAnchoringManager.prototype._anchoringStrategies = [];

    EnhancedAnchoringManager.prototype.registerAnchoringStrategy = function(strategy) {
      if (strategy.priority == null) {
        strategy.priority = 50;
      }
      this._anchoringStrategies.push(strategy);
      return this._anchoringStrategies.sort(function(s1, s2) {
        return s1.priority > s2.priority;
      });
    };

    EnhancedAnchoringManager.prototype._documentAccessStrategies = [];

    EnhancedAnchoringManager.prototype.registerDocumentAccessStrategy = function(strategy) {
      if (strategy.priority == null) {
        strategy.priority = 50;
      }
      this._documentAccessStrategies.push(strategy);
      return this._documentAccessStrategies.sort(function(s1, s2) {
        return s1.priority > s2.priority;
      });
    };

    EnhancedAnchoringManager.prototype._highlighters = [];

    EnhancedAnchoringManager.prototype.registerHighlighter = function(highlighter) {
      if (highlighter.priority == null) {
        highlighter.priority = 50;
      }
      this._highlighters.push(highlighter);
      return this._highlighters.sort(function(h1, h2) {
        return h1.priority > h2.priority;
      });
    };

    EnhancedAnchoringManager.prototype._setupAnchorEvents = function() {
      var _this = this;
      return this.annotator.on('annotationUpdated', function(annotation) {
        var anchor, index, _i, _len, _ref, _results;
        _ref = annotation.anchors || [];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          anchor = _ref[_i];
          _results.push((function() {
            var _j, _ref1, _ref2, _ref3, _results1;
            _results1 = [];
            for (index = _j = _ref1 = anchor.startPage, _ref2 = anchor.endPage; _ref1 <= _ref2 ? _j <= _ref2 : _j >= _ref2; index = _ref1 <= _ref2 ? ++_j : --_j) {
              _results1.push((_ref3 = anchor.highlight[index]) != null ? _ref3.annotationUpdated() : void 0);
            }
            return _results1;
          })());
        }
        return _results;
      });
    };

    EnhancedAnchoringManager.prototype._chooseAccessPolicy = function() {
      var s, _i, _len, _ref,
        _this = this;
      if (this.domMapper) {
        return;
      }
      _ref = this._documentAccessStrategies;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        s = _ref[_i];
        if (s.applicable()) {
          console.log("Selected document access strategy: " + s.name);
          this.domMapper = this.annotator.domMapper = s.get();
          addEventListener("docPageMapped", function(evt) {
            return _this._realizePage(evt.pageIndex);
          });
          addEventListener("docPageUnmapped", function(evt) {
            return _this._virtualizePage(evt.pageIndex);
          });
          return this;
        }
      }
    };

    EnhancedAnchoringManager.prototype.initAnchoring = function() {
      return this._chooseAccessPolicy();
    };

    EnhancedAnchoringManager.prototype._getTargetFromSelection = function(selection) {
      var c, dfd, error, promises, selectors, _ref,
        _this = this;
      dfd = Annotator.$.Deferred();
      selectors = [];
      promises = (function() {
        var _i, _len, _ref, _results;
        _ref = this._selectorCreators;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          c = _ref[_i];
          try {
            _results.push(c.describe(selection).then(function(description) {
              var selector, _j, _len1, _results1;
              _results1 = [];
              for (_j = 0, _len1 = description.length; _j < _len1; _j++) {
                selector = description[_j];
                _results1.push(selectors.push(selector));
              }
              return _results1;
            }));
          } catch (_error) {
            error = _error;
            console.log("Internal error while using selection descriptor", "'" + c.name + "':");
            _results.push(console.log(error.stack));
          }
        }
        return _results;
      }).call(this);
      (_ref = Annotator.$).when.apply(_ref, promises).always(function() {
        if (selectors.length) {
          return dfd.resolve({
            source: _this.annotator.getHref(),
            selector: selectors
          });
        } else {
          return dfd.reject("No selector creator could describe this selection.");
        }
      });
      return dfd.promise();
    };

    EnhancedAnchoringManager.prototype._getTargetsFromSelections = function(selections) {
      var dfd, promises, selection, targets, _ref,
        _this = this;
      dfd = Annotator.$.Deferred();
      targets = {};
      promises = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = selections.length; _i < _len; _i++) {
          selection = selections[_i];
          _results.push(this._getTargetFromSelection(selection).then((function(target) {
            return targets[selection] = target;
          }), (function(reason) {
            return console.log("Could not create target from selection", selection, ":", reason);
          })));
        }
        return _results;
      }).call(this);
      (_ref = Annotator.$).when.apply(_ref, promises).always(function() {
        var p, sel;
        if (__indexOf.call((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = promises.length; _i < _len; _i++) {
            p = promises[_i];
            _results.push(p.state());
          }
          return _results;
        })(), "rejected") >= 0) {
          return dfd.reject("Failed to create the targets");
        } else {
          return dfd.resolve((function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = selections.length; _i < _len; _i++) {
              sel = selections[_i];
              _results.push(targets[sel]);
            }
            return _results;
          })());
        }
      });
      return dfd.promise();
    };

    EnhancedAnchoringManager.prototype.findSelector = function(selectors, type) {
      var selector, _i, _len;
      for (_i = 0, _len = selectors.length; _i < _len; _i++) {
        selector = selectors[_i];
        if (selector.type === type) {
          return selector;
        }
      }
      return null;
    };

    EnhancedAnchoringManager.prototype._createAnchorWithStrategies = function(annotation, target, strategies, promise) {
      var error, iteration, onFail, s,
        _this = this;
      if (!strategies.length) {
        promise.reject("no more strateges to try");
        return;
      }
      s = strategies.shift();
      onFail = function(error, boring) {
        if (boring == null) {
          boring = false;
        }
        if (!(boring && false)) {
          console.log("Anchoring strategy", "'" + s.name + "'", "has failed:", error);
        }
        return _this._createAnchorWithStrategies(annotation, target, strategies, promise);
      };
      try {
        iteration = s.create(target);
        iteration.then(function(anchor) {
          var pageIndex, _base, _i, _ref, _ref1;
          if (!((anchor.startPage != null) && (anchor.endPage != null) && (anchor.quote != null))) {
            console.log("Warning: starategy", "'" + s.name + "'", "has returned an anchor without the mandatory fields.", anchor);
            onFail("internal error");
          }
          anchor.strategy = s;
          anchor.annotator = _this;
          anchor.annotation = annotation;
          anchor.target = target;
          anchor.highlight = {};
          target.quote = anchor.quote;
          if (anchor.diffHTML) {
            target.diffHTML = anchor.diffHTML;
          } else {
            delete anchor.diffHTML;
          }
          if (anchor.diffCaseOnly) {
            target.diffCaseOnly = anchor.diffCaseOnly;
          }
          delete anchor.diffCaseOnly;
          annotation.anchors.push(anchor);
          _this.removeFromSet(annotation, _this.orphans);
          if (annotation.anchors.length === annotation.target.length) {
            _this.removeFromSet(annotation, _this.halfOrphans);
          } else {
            _this.addToSet(annotation, _this.halfOrphans);
          }
          for (pageIndex = _i = _ref = anchor.startPage, _ref1 = anchor.endPage; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; pageIndex = _ref <= _ref1 ? ++_i : --_i) {
            if ((_base = _this.anchors)[pageIndex] == null) {
              _base[pageIndex] = [];
            }
            _this.anchors[pageIndex].push(anchor);
          }
          return promise.resolve(anchor);
        }).fail(onFail);
      } catch (_error) {
        error = _error;
        console.log("While trying anchoring strategy", "'" + s.name + "':");
        console.log(error.stack);
        onFail("see exception above");
      }
      return null;
    };

    EnhancedAnchoringManager.prototype._createAnchor = function(annotation, target) {
      var dfd;
      if (target == null) {
        throw new Error("Trying to find anchor for null target!");
      }
      dfd = Annotator.$.Deferred();
      this._createAnchorWithStrategies(annotation, target, this._anchoringStrategies.slice(), dfd);
      return dfd.promise();
    };

    EnhancedAnchoringManager.prototype._realizeAnchor = function(anchor, page) {
      var created, error, p, pagesTodo, promises, renderedPages, _i, _j, _len, _ref, _ref1, _ref2, _results,
        _this = this;
      if (anchor.fullyRealized) {
        return;
      }
      renderedPages = (function() {
        _results = [];
        for (var _i = _ref = anchor.startPage, _ref1 = anchor.endPage; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; _ref <= _ref1 ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this).filter(function(index) {
        return _this.domMapper.isPageMapped(index);
      });
      pagesTodo = renderedPages.filter(function(index) {
        return anchor.highlight[index] == null;
      });
      if (!pagesTodo.length) {
        return;
      }
      try {
        created = [];
        promises = [];
        for (_j = 0, _len = pagesTodo.length; _j < _len; _j++) {
          page = pagesTodo[_j];
          promises.push(p = this._createHighlight(anchor, page));
          p.then(function(hl) {
            return created.push(anchor.highlight[page] = hl);
          });
          p.fail(function(e) {
            return console.log("Error while trying to create highlight:", e);
          });
        }
        (_ref2 = Annotator.$).when.apply(_ref2, promises).always(function() {
          anchor.fullyRealized = (renderedPages.length === anchor.endPage - anchor.startPage + 1) && (created.length === pagesTodo.length);
          if (created.length) {
            return _this.annotator.publish('highlightsCreated', created);
          }
        });
      } catch (_error) {
        error = _error;
        console.log("Internal error:");
        console.log(error.stack);
      }
      return null;
    };

    EnhancedAnchoringManager.prototype._virtualizeAnchor = function(anchor, pageIndex) {
      var error, highlight;
      highlight = anchor.highlight[pageIndex];
      if (highlight == null) {
        return;
      }
      try {
        highlight.removeFromDocument();
      } catch (_error) {
        error = _error;
        console.log("Could not remove HL from page", pageIndex, ":", error.stack);
      }
      delete anchor.highlight[pageIndex];
      anchor.fullyRealized = false;
      this.annotator.publish('highlightRemoved', highlight);
      return null;
    };

    EnhancedAnchoringManager.prototype._verifyAnchor = function(anchor, reason, data) {
      var dfd, error,
        _this = this;
      dfd = Annotator.$.Deferred();
      if (anchor.strategy.verify) {
        try {
          anchor.strategy.verify(anchor, reason, data).then(function(valid) {
            if (!valid) {
              _this._removeAnchor(anchor);
            }
            return dfd.resolve();
          });
        } catch (_error) {
          error = _error;
          console.log("Error while executing anchor's verify method:", error.stack);
          this._removeAnchor(anchor);
          dfd.resolve();
        }
      } else {
        console.log("Can't verify this anchor, because the", "'" + anchor.strategy.name + "'", "strategy (which was responsible for creating this anchor)", "did not specify a verify function.");
        this._removeAnchor(anchor);
        dfd.resolve();
      }
      return dfd.promise();
    };

    EnhancedAnchoringManager.prototype._removeAnchor = function(anchor) {
      var anchors, annotation, index, _i, _ref, _ref1;
      for (index = _i = _ref = anchor.startPage, _ref1 = anchor.endPage; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; index = _ref <= _ref1 ? ++_i : --_i) {
        this._virtualizeAnchor(anchor, index);
        anchors = this.anchors[index];
        this.removeFromSet(anchor, anchors);
        if (!anchors.length) {
          delete this.anchors[index];
        }
      }
      annotation = anchor.annotation;
      this.removeFromSet(anchor, annotation.anchors);
      if (annotation.anchors.length) {
        return this.addToSet(annotation, this.halfOrphans);
      } else {
        this.addToSet(annotation, this.orphans);
        return this.removeFromSet(annotation, this.halfOrphans);
      }
    };

    EnhancedAnchoringManager.prototype._findAnchorForTarget = function(annotation, target) {
      var anchor, _i, _len, _ref;
      _ref = annotation.anchors;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        anchor = _ref[_i];
        if (anchor.target === target) {
          return anchor;
        }
      }
      return null;
    };

    EnhancedAnchoringManager.prototype._hasAnchorForTarget = function(annotation, target) {
      var anchor;
      anchor = this._findAnchorForTarget(annotation, target);
      return anchor != null;
    };

    EnhancedAnchoringManager.prototype._anchorAnnotation = function(annotation, targetFilter, publishEvent) {
      var dfd, index, promises, shouldDo, t, _ref,
        _this = this;
      if (publishEvent == null) {
        publishEvent = false;
      }
      if (targetFilter == null) {
        targetFilter = function(target) {
          return true;
        };
      }
      shouldDo = function(target) {
        var hasAnchor, result;
        hasAnchor = _this._hasAnchorForTarget(annotation, target);
        result = (!hasAnchor) && (targetFilter(target));
        return result;
      };
      annotation.quote = (function() {
        var _i, _len, _ref, _results;
        _ref = annotation.target;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          t = _ref[_i];
          _results.push(t.quote);
        }
        return _results;
      })();
      if (annotation.anchors == null) {
        annotation.anchors = [];
      }
      promises = (function() {
        var _i, _len, _ref, _results,
          _this = this;
        _ref = annotation.target;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          t = _ref[_i];
          if (!(shouldDo(t))) {
            continue;
          }
          index = annotation.target.indexOf(t);
          _results.push(this._createAnchor(annotation, t).then(function(anchor) {
            annotation.quote[index] = t.quote;
            return _this._realizeAnchor(anchor);
          }));
        }
        return _results;
      }).call(this);
      dfd = Annotator.$.Deferred();
      (_ref = Annotator.$).when.apply(_ref, promises).always(function() {
        var p;
        annotation.quote = annotation.quote.filter(function(q) {
          return q != null;
        }).join(' / ');
        if (__indexOf.call((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = promises.length; _i < _len; _i++) {
            p = promises[_i];
            _results.push(p.state());
          }
          return _results;
        })(), "resolved") >= 0) {
          if (_this._changedAnnotations != null) {
            _this._changedAnnotations.push(annotation);
          }
          if (publishEvent) {
            _this.annotator.publish("annotationsLoaded", [[annotation]]);
          }
        }
        return dfd.resolve(annotation);
      });
      return dfd.promise();
    };

    EnhancedAnchoringManager.prototype._anchorAllAnnotations = function(targetFilter) {
      var annotation, annotations, dfd, promises, _ref,
        _this = this;
      dfd = Annotator.$.Deferred();
      annotations = this.halfOrphans.concat(this.orphans);
      this._changedAnnotations = [];
      promises = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = annotations.length; _i < _len; _i++) {
          annotation = annotations[_i];
          _results.push(this._anchorAnnotation(annotation, targetFilter));
        }
        return _results;
      }).call(this);
      (_ref = Annotator.$).when.apply(_ref, promises).always(function() {
        if (_this._changedAnnotations.length) {
          _this.annotator.publish("annotationsLoaded", [_this._changedAnnotations]);
        }
        delete _this._changedAnnotations;
        return dfd.resolve();
      });
      return dfd.promise();
    };

    EnhancedAnchoringManager.prototype._createHighlightUsingHighlighters = function(anchor, page, highlighters, promise) {
      var error, h, iteration, onFail,
        _this = this;
      if (!highlighters.length) {
        promise.reject("No highlighter that could handle anchor type" + anchor.type);
        return;
      }
      h = highlighters.shift();
      onFail = function(error, boring) {
        if (boring == null) {
          boring = false;
        }
        if (!boring) {
          console.log("Highlighter", "'" + s.name + "'", "has failed:", error);
        }
        return _this._createHighlightUsingHighlighters(anchor, page, highlighters, promise);
      };
      try {
        iteration = h.highlight(anchor, page);
        iteration.then(function(highlight) {
          return promise.resolve(highlight);
        }).fail(onFail);
      } catch (_error) {
        error = _error;
        console.log("While trying highlighter", "'" + h.name + "':");
        console.log(error.stack);
        onFail("see exception above");
      }
      return null;
    };

    EnhancedAnchoringManager.prototype._createHighlight = function(anchor, page) {
      var dfd;
      dfd = Annotator.$.Deferred();
      this._createHighlightUsingHighlighters(anchor, page, this._highlighters.slice(), dfd);
      return dfd.promise();
    };

    EnhancedAnchoringManager.prototype.getHighlights = function(annotations) {
      var anchor, anchors, annotation, hl, page, results, _i, _j, _len, _len1, _ref, _ref1, _ref2;
      results = [];
      if (annotations != null) {
        for (_i = 0, _len = annotations.length; _i < _len; _i++) {
          annotation = annotations[_i];
          _ref = annotation.anchors;
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            anchor = _ref[_j];
            _ref1 = anchor.highlight;
            for (page in _ref1) {
              hl = _ref1[page];
              results.push(hl);
            }
          }
        }
      } else {
        _ref2 = this.anchors;
        for (page in _ref2) {
          anchors = _ref2[page];
          $.merge(results, (function() {
            var _k, _len2, _results;
            _results = [];
            for (_k = 0, _len2 = anchors.length; _k < _len2; _k++) {
              anchor = anchors[_k];
              if (anchor.highlight[page] != null) {
                _results.push(anchor.highlight[page]);
              }
            }
            return _results;
          })());
        }
      }
      return results;
    };

    EnhancedAnchoringManager.prototype._realizePage = function(index) {
      var anchor, _i, _len, _ref, _ref1;
      if (!this.domMapper.isPageMapped(index)) {
        return;
      }
      _ref1 = (_ref = this.anchors[index]) != null ? _ref : [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        anchor = _ref1[_i];
        this._realizeAnchor(anchor);
      }
      return null;
    };

    EnhancedAnchoringManager.prototype._virtualizePage = function(index) {
      var anchor, _i, _len, _ref, _ref1;
      _ref1 = (_ref = this.anchors[index]) != null ? _ref : [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        anchor = _ref1[_i];
        this._virtualizeAnchor(anchor, index);
      }
      return null;
    };

    EnhancedAnchoringManager.prototype._verifyAllAnchors = function(reason, data) {
      var anchor, anchors, dfd, page, promises, _i, _len, _ref, _ref1, _ref2;
      if (reason == null) {
        reason = "no reason in particular";
      }
      if (data == null) {
        data = null;
      }
      dfd = Annotator.$.Deferred();
      promises = [];
      _ref = this.anchors;
      for (page in _ref) {
        anchors = _ref[page];
        _ref1 = anchors.slice();
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          anchor = _ref1[_i];
          promises.push(this._verifyAnchor(anchor, reason, data));
        }
      }
      (_ref2 = Annotator.$).when.apply(_ref2, promises).always(function() {
        return dfd.resolve();
      });
      return dfd.promise();
    };

    EnhancedAnchoringManager.prototype._reanchorAllAnnotations = function(reason, data, targetFilter) {
      var dfd,
        _this = this;
      if (reason == null) {
        reason = "no reason in particular";
      }
      if (data == null) {
        data = null;
      }
      if (targetFilter == null) {
        targetFilter = null;
      }
      dfd = Annotator.$.Deferred();
      this._verifyAllAnchors(reason, data).then(function() {
        return _this._anchorAllAnnotations(targetFilter).then(function() {
          return dfd.resolve();
        });
      });
      return dfd.promise();
    };

    EnhancedAnchoringManager.prototype.onSuccessfulSelection = function(event, immediate) {
      var dfd,
        _this = this;
      if (immediate == null) {
        immediate = false;
      }
      dfd = Annotator.$.Deferred();
      if (event == null) {
        throw new Error("Called onSuccessfulSelection without an event!");
      }
      if (event.segments == null) {
        throw new Error("Called onSuccessulSelection with an event with missing segments!");
      }
      if (!this.annotator.canAnnotate) {
        dfd.reject("I can't annotate right now. (Maybe already creating an annotation?)");
        return dfd.promise();
      }
      this._getTargetsFromSelections(event.segments).then((function(targets) {
        _this._selectedTargets = targets;
        _this._selectedData = event.annotationData;
        if (immediate) {
          _this.annotator.onAdderClick(event);
          return dfd.resolve("adder clicked");
        } else {
          _this.annotator.adder.css(Annotator.util.mousePosition(event, _this.annotator.wrapper[0])).show();
          return dfd.resolve("adder shown");
        }
      }), (function(reason) {
        return dfd.reject("Looks like I can't annotate these parts. Sorry.");
      }));
      return dfd.promise();
    };

    EnhancedAnchoringManager.prototype.onFailedSelection = function(event) {
      this.annotator.adder.hide();
      this._selectedTargets = [];
      return delete this._selectedData;
    };

    EnhancedAnchoringManager.prototype.setupAnnotation = function(annotation) {
      if (typeof this.initAnchoring === "function") {
        this.initAnchoring();
      }
      if (annotation.target == null) {
        annotation.target = this._selectedTargets;
      }
      this._selectedTargets = [];
      if (annotation.target == null) {
        throw new Error("Can not run setupAnnotation(). No target or selection available.");
      }
      this.orphans.push(annotation);
      return this._anchorAnnotation(annotation);
    };

    EnhancedAnchoringManager.prototype.deleteAnnotation = function(annotation) {
      var a, _i, _len, _ref;
      if (annotation.anchors != null) {
        _ref = annotation.anchors;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          a = _ref[_i];
          this._removeAnchor(a);
        }
      }
      this.removeFromSet(annotation, this.orphans);
      this.annotator.publish('annotationDeleted', [annotation]);
      return annotation;
    };

    EnhancedAnchoringManager.prototype.setAnnotationTemporary = function(annotation, value) {
      var anchor, hl, page, _i, _len, _ref, _results;
      _ref = annotation.anchors;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        anchor = _ref[_i];
        _results.push((function() {
          var _ref1, _results1;
          _ref1 = anchor.highlight;
          _results1 = [];
          for (page in _ref1) {
            hl = _ref1[page];
            _results1.push(hl.setTemporary(value));
          }
          return _results1;
        })());
      }
      return _results;
    };

    return EnhancedAnchoringManager;

  })();

  Annotator.Plugin.EnhancedAnchoring = (function(_super) {
    __extends(EnhancedAnchoring, _super);

    function EnhancedAnchoring() {
      _ref = EnhancedAnchoring.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    EnhancedAnchoring.prototype.pluginInit = function() {
      var k, manager, v, _results;
      this.annotator.anchoring = manager = new EnhancedAnchoringManager(this.annotator);
      _results = [];
      for (k in manager) {
        if (!__hasProp.call(manager, k)) continue;
        v = manager[k];
        if (k[0] !== "_" && k !== "annotator") {
          _results.push(this.annotator[k] = v);
        }
      }
      return _results;
    };

    return EnhancedAnchoring;

  })(Annotator.Plugin);

  Annotator.Highlight = Highlight;

}).call(this);

//
//@ sourceMappingURL=annotator.enhancedanchoring.map